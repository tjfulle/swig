<!--
This document is formatted with [Github-flavored
Markdown](https://github.github.com/gfm/)

Run with:

pandoc --from=gfm+smart --no-highlight \
-M title:"SWIG and Fortran" -M author:"Seth R Johnson" \
--toc --standalone -H style.css -o ../Fortran.html Fortran.md

-->

# Overview 

This chapter describes how to create interfaces to C and C++ data and functions
in the target language of Fortran, a long-lived scientific
programming language.
The primary motivation for adding the Fortran language to SWIG is to provide an
automated means of adapting massively parallel scientific codes to modern solvers
and GPU-accelerated kernels in the Trilinos numerical library package.
But in addition to this useful capability, adding Fortran as a SWIG target
language has potential to
simplify and accelerate numerous existing Fortran codes that do not require
advanced numerical solvers.
By implementing automated coupling of C++ libraries to Fortran, we open up a
new world of capability to Fortran users.

# Fundamental concepts

SWIG generates simple, flat C functions that provide access to underlying C/C++
data and functions that may operate on complex data types.
Fortran 2003 introduced features designed to finally provide standardized
interactions between Fortran and ANSI C.  The wrapper functions generated by
SWIG take and return only these `ISO_C_BINDING`-compatible data
types. These functions are responsible for converting any complex C
datatypes to simpler ones compatible with Fortran.

In addition to generating a C++ file of wrapper code, SWIG generates a Fortran
module (one per `%module` SWIG directive).
In the private "interface" section of this module, SWIG generates function
interface declarations with the `BIND(C)` qualifier that exactly mirror the
generated wrapper functions.
In SWIG, all of the C-generated wrapper functions are prefixed with `swigc_`,
so all of these interface functions likewise start with `swigc_`. 

Finally, SWIG generates additional Fortran code that translates the simple
function arguments and return values into their Fortran equivalents.
For fundamental data types this conversion can simply be assignment,
but other complex transformations can be performed that allow better native
integration of C++ with Fortran.
For example, a `const int*` return value could be transformed to
Fortran array `pointer` instead of being left as an opaque `type(C_PTR)`.

SWIG also generates "proxy" classes: thin Fortran 2003 "derived type"
declarations that bind `swigc_` functions to allow creation and manipulation of
C++ class instances in Fortran.

## Nomenclature

The terminology in C/C++ and Fortran is different enough to be potentially
confusing to a user not intimately familiar with both languages. The author is
more familiar with C++ than Fortran but has endeavored to use the correct
Fortran terms when describing the Fortran implementation. The following table
presents some essentially equivalent concepts and names in the two languages:

| C/C++                            | Fortran                     |
|----------------------------------|-----------------------------|
| struct/class                     | derived type                |
| function                         | procedure                   |
| member function                  | type-bound procedure        |
| function that returns void       | subroutine                  |
| function that returns non-void   | function                    |
| overloaded function              | generic interface           |
| floating point number            | real                        |
| fundamental type                 | intrinsic type              |
| derived type                     | extended type               |
| class instance                   | structure                   |
| parameter list                   | dummy arguments             |

## Identifiers

C and C++ have different rules for identifiers (i.e. variable names, function
names, class names) than Fortran. The following restrictions apply to Fortran
that do not apply to C and C++:
- Names are **case insensitive**
- Names may not begin with an underscore
- Names may be no longer than 63 characters

SWIG automatically renames identifiers that start with a leading underscore. It
keeps a symbol table of publicly accessible Fortran identifiers (as their
lower-cased, renamed versions) and warns about and ignores duplicate names.

There is also no "namespace" concept in Fortran 2003 aside from defining
procedures and types in separate modules. (Fortran 2008 supports submodules, but
these are more akin to private namespaces inside a translation unit in C++.)
Keep in mind that the extremely flexible `%rename` directive can be used to
adjust the symbolic names created in SWIG.

## Running SWIG

Suppose that we have a SWIG interface file `example.i` with the following
contents:
```swig
/* File: example.i */
%module forexample

%{
/* include header */
#include "cexample.h"
%}

%include "cexample.h"
```
where `cexample.h` contains the simple function declaration:
```c
int fact(int n);
```

To generate SWIG Fortran wrappers for this file, run
```sh
$ swig -fortran example.i
```
and SWIG will create two files: a C interface file containing something like
```c
/* SNIP */
/* include header */
#include "cexample.h"
/* SNIP */
SWIGEXPORT int swigc_fact(int const *farg1) {
  int fresult;
  int arg1;
  int result;
  
  arg1 = *farg1;
  result = (int)fact(arg1);
  fresult = result;
  return fresult;
}
/* SNIP */
```
and a Fortran interface file with something like:
```fortran
module forexample
 use, intrinsic :: ISO_C_BINDING
 implicit none
 public :: fact
private
interface
 function swigc_fact(farg1) &
   bind(C, name="swigc_fact") &
   result(fresult)
  use, intrinsic :: ISO_C_BINDING
  integer(C_INT) :: fresult
  integer(C_INT), intent(in) :: farg1
 end function
end interface
contains
 function fact(n) &
   result(swig_result)
  use, intrinsic :: ISO_C_BINDING
  integer(C_INT) :: swig_result
  integer(C_INT), intent(in) :: n
  integer(C_INT) :: fresult 
  integer(C_INT) :: farg1 
  farg1 = n
  fresult = swigc_fact(farg1)
  swig_result = fresult
 end function
end module forexample
```

The `%module` declaration in the `.i` file resulted in the file names
`forexample.f90` and the name in `module forexample`; file name `example.i`
resulted in the C wrapper file by default being named `example_wrap.c`, and the
`#include` command was explicitly inserted into the C wrapper file
`example_wrap.c`. The `%include` command in the `.i` file directed SWIG to
parse the header file `cexample.h` and generate an interface for the function
declaration that it discovered.

In the generated C wrapper code above, `int swigc_fact(int const *farg1)` is
the wrapper code generated by SWIG to provide a Fortran-compatible interface
with the C function `fact`; the `function swigc_fact(farg1)` interface in
Fortran is the exact equivalent of that C function; and the "public" function
`fact` in the `contains` section of the Fortran module is the Fortran proxy
function generated by SWIG.

Note that since this function takes and returns
simple data types, the C and Fortran wrapper functions have some code that
could be easily simplified by hand. (A compiler with optimization enabled
automatically does this, in fact.) However, for more complex data types, SWIG
shows its power by generating complex expressions that seamlessly translate
between C and Fortran data types without requiring user intervention.

## Compiling a simple Fortran program

Several examples are provided in the SWIG source code under
`Examples/fortran/`. In the `barefunctions` example, the Fortran `main` program
can be compiled using the following sequence of commands:
```sh
swig -fortran -c++ bare.i
$CXX -c bare_wrap.cxx
$CXX -c bare.cxx -o barecxx.o
$FC gfortran -c bare.f90
$FC runme.f90 bare.o bare_wrap.o barecxx.o -lstdc++ -o run.exe
```
Note that since this was a C++ program, the `-c++` option must be passed to SWIG
and `-lstdc++` must be passed to the final link command.

## Compiling more complex Fortran/C/C++ programs

The figure below shows how C++, SWIG, and Fortran code can be integrated into
libraries and linked to form executables. The file icons are user-written
files; circles are executables; flat cylinders are generated on-disk files; and
the final box is the executable. The arrow signifies "generates" or "is used
by."

<img src="fortran-data.png" alt="SWIG python data flow" height="504"
width="352"/>

We provide CMake modules and commands to simplify this process; again, see the
example directories for usage instructions.

<!-- ###################################################################### -->

# Basic Fortran/C data type interoperability

The Fortran SWIG module relies on Fortran 2003's C interoperability features,
both the `ISO_C_BINDING` intrinsic module and the specifications of the
standard. Every effort has been made to conform to the standard in the
translation layer between C++ and Fortran and to eliminate potential pitfalls
of interoperability.

We anticipate that future extensions of Fortran/C interoperability will
increase the capability of the SWIG wrapper interface.
However, many features of C and C++ are outside the scope of Fortran's
interoperability features.  Even some features that *are* interoperable,such as
enumerations and structs, have capabilities that do
not map between the two languages. With this SWIG module we attempt to
extend the
Fortran/C++ mapping as much as possible, keeping in mind that Fortran and C are
inherently different languages.

## Fundamental types

SWIG maps the ISO Fortran equivalents
via the `use, intrinsic :: ISO_C_BINDING` statement. The types mapped directly
by SWIG are:

| C type          |   Fortran type          |
|-----------------|-------------------------|
| `signed char`   | `integer(C_SIGNED_CHAR)`|
| `short`         | `integer(C_SHORT)`      |
| `int`           | `integer(C_INT)`        |
| `long`          | `integer(C_LONG)`       |
| `long long`     | `integer(C_LONG_LONG)`  |
| `size_t`        | `integer(C_SIZE_T)`     |
| `float`         | `real(C_FLOAT)`         |
| `double`        | `real(C_DOUBLE)`        |
| `char`          | `character(C_CHAR)`     |

Pointers and references to the fundamental types are returned as scalar Fortran
pointers: because the C return value does not contain any information about the
shape of the data being pointed to, it is not possible to directly construct an
array from a pointed-to value.

However, [advanced typemaps](#typemaps) can be constructed (and indeed [are
provided](#provided-typemaps) with the SWIG Fortran standard library) that
*can* return that information or extend the Fortran
interface to obtain the additional information needed to return an array
pointer.

### Other integer types

Fortran has no intrinsic unsigned datatypes, so the specification says to treat
`unsigned` datatypes as their `signed` counterparts. Note that this means
`unsigned char` will be wrapped as a Fortran integer by default.

No checking for negativity or boundedness is done when converting the
datatypes. In part this is because intentionally out-of-range values (e.g.,
`static_cast<size_t>(-1)`) are often used as sentinels.

A more complete set of typemaps for the full set of integer types available in
`<stdint.h>` can be used by `%include <cstdint>`.

### Boolean/logical values

The astute reader may notice the omission of `C_BOOL` from the above table.
Because of the different treatment of booleans in C and Fortran, guaranteeing
the sizes of the `bool` are equivalent in the two languages does _not_ guarantee
the equivalence of their values. See [this discussion topic](https://software.intel.com/en-us/forums/intel-fortran-compiler-for-linux-and-mac-os-x/topic/594856)
for details of the subtle compatibility, but in brief, Fortran's `.true.` is
defined by having the least significant bit set to `1`, whereas C defines it
as any nonzero value. So the value `2` would be `true` in C but `false` in
Fortran. A special typemap inserts wrapper code to explicitly convert 
booleans between the two languages.

### Characters

Since `char*`, `const char[]`, etc. typically signify character strings in C
and C++, the results of the default wrapping for characters may not be what you
expect. See the [`<cstring.i>` header](#c-string) for how to wrap character
arrays.

## Pointers and references

C pointers and mutable references are treated as Fortran pointers. Suppose a C
function that returns a pointer to an array element at a given index:
```c
double* get_array_element(int x);
```

This generates the following Fortran interface:
```fortran
function get_array_element(x) &
      result(swig_result)
  use, intrinsic :: ISO_C_BINDING
  real(C_DOUBLE), pointer :: swig_result
  integer(C_INT), intent(in) :: x
  type(C_PTR) :: fresult 
  integer(C_INT) :: farg1 

  farg1 = x
  fresult = swigc_get_array_element(farg1)
  call c_f_pointer(fresult, swig_result)
end function
```

To set the element at array index 2 to the value 512, 
```fortran
real(C_DOUBLE), pointer :: rptr
rptr => get_array_element(2)
rptr = 512.0d0
```
Note, and this is **very important**, that a function returning a pointer must
not be *assigned*; the *pointer assignment* operator `=>` must be used.

Mutable references are treated identically. However, *const* references to
primitive types are treated as values:
```c++
const double& get_const_array_element(int x);
```
will generate
```fortran
function get_const_array_element(x) &
    result(swig_result)
  use, intrinsic :: ISO_C_BINDING
  real(C_DOUBLE) :: swig_result
  integer(C_INT), intent(in) :: x
  real(C_DOUBLE) :: fresult 
  integer(C_INT) :: farg1 

  farg1 = x
  fresult = swigc_get_const_array_element(farg1)
  swig_result = fresult
end function
```
which must be called like
```fortran
real(C_DOUBLE) :: rval
rval = get_const_array_element(2)
```

Combining the two examples, you could copy value of element 3 to element 2 with
the following code block:
```fortran
real(C_DOUBLE), pointer :: rptr
rptr => get_array_element(2)
rptr = get_const_array_element(3)
```
First the pointer is assigned, then the pointed-to data is assigned.

## Strings

Fortran's interoperability specifications prohibit using `C_LOC` on variables
with length type parameters: thus the standard `character(len=*)` type cannot
be natively passed to C. Instead, SWIG injects small helper functions that
convert between strings and arrays of characters. The character arrays are then
passed through the interface layer to C, which can reconstruct the full string.

Because the actual Fortran string length is passed to C during this process,
character arrays with the null character can be converted to byte objects
without unexpected string truncation.

Currently SWIG provides typemaps (see the [Typemaps section](#provided-typemaps)
) that allow transparent conversion between Fortran character arrays and
null-terminated C strings, as well as C++ `std::string` objects.

## Arrays

SWIG supports a subset of direct Fortran array translation. If a
single-dimensional array size is explicitly specified in a C function's
signature, the corresponding argument will be an explicit-shape Fortran array.

One caution is that occasionally arrays will be defined using nontrivial C
expressions rather than explicit integers. Even though these can be evaluated
by C at compile time, the unevaluated expression cannot be propagated into the
Fortran wrapper code. SWIG checks whether the expression is a combination of
base-10 numbers and the simple arithmetic expressions `+-*/`; if so, it is
allowable. Otherwise, a warning is emitted and the array is ignored.
```c
int global_data1[8]; /* OK */
int global_data2[];  /* OK */
int global_data3[sizeof(int)];  /* WARN AND IGNORE */
```

## Classes and structs

In C++, the only difference between a `struct` and a `class` is the default
*access specifier*: `public` for `struct` and `private` for `class`. As with
the rest of SWIG, only public methods and data are wrapped.

These are both wrapped as *derived types* in Fortran. By default, these derived
types are "proxy" classes, which hold a C pointer to a C++ class instance.
Roughly speaking, classes are mapped from
```c++
class Foo {
public:
  void bar();
};
```
to
```fortran
type :: Foo
  type(SwigClassWrapper), public :: swigdata
contains
  procedure :: bar => swigf_Foo_bar
end type
```

Unlike many other SWIG languages, the proxy code produced by
Fortran is *strongly typed*: mistakenly using the wrong type will result in a
Fortran compiler error as opposed to a runtime error.

## Ignored or unimplemented forward-declared structs and classes

Some functions may include references or pointers to classes that are not
wrapped by Fortran proxy functions. In these cases, an opaque derived type
called `SwigUnknownClass` will be generated and used as a placeholder for the
argument or return value. These could theoretically be passed between wrapped
SWIG functions, although no type checking will be performed to ensure that the
unknown classes are the correct types.

## Enumerations

Fortran 2003 implements C enumerations using the `ENUM, BIND(C)` statement.
These enumerators are simply a set of loosely grouped compile-time integer
constants that are guaranteed to be compatible with C enumerators. Unlike C++,
all enumerators in Fortran are anonymous.

To associate a C enumeration name with the Fortran
generated wrappers, SWIG generates an additional enumeration with the C class
name and a dummy value of `-1`. The enumeration generated from the C code
```c
enum MyEnum {
    RED = 0,
    GREEN,
    BLUE,
    BLACK = -1
};
```
looks like:
```fortran
 enum, bind(c)
  enumerator :: MyEnum = -1
  enumerator :: RED = 0
  enumerator :: GREEN = RED + 1
  enumerator :: BLUE = GREEN + 1
  enumerator :: BLACK = -1
 end enum
```
 
These enumerators are treated as standard C integers in the C wrapper code
code. In the Fortran wrapper code, procedures that use the enumeration use the
type `integer(kind(MyEnum))` to clearly indicate what enum type is required.

Some C++ enumeration definitions cannot be natively interpreted by a Fortran
compiler (e.g. `FOO = 0x12,` or `BAR = sizeof(int),`), so these are defined in
the C++ wrapper code and _bound_ in the Fortran wrapper code:
```fortran
integer(C_INT), protected, public, &
   bind(C, name="swigc_FOO") :: FOO
```
The `%enumerator` and `%noenumerator` directives can be used to explicitly
enable and disable treatment of a C++ `enum` as a Fortran enumerator. Disabling
the enumerator feature causes the value to be wrapped as externally-bound C
integers.

## Function pointers

It is possible to pass function pointers both from C to Fortran and from
Fortran to C using SWIG. Currently, function pointer variables
simply generate opaque `type(C_FUNPTR)` objects, and it is up to the user to
convert to a Fortran procedure pointer
using [c_f_procpointer](https://software.intel.com/en-us/node/679091):
```fortran
subroutine CallIt(cp) bind(c)
  use, intrinsic :: iso_c_binding
  type(c_funptr), intent(in) :: cp
  abstract interface
    subroutine Add_Int(i) bind(c)
      import
      integer(c_int), intent(inout) :: i
    end subroutine Add_Int
  end interface
  procedure(Add_Int), pointer :: fp
  integer(c_int) :: j

  call c_f_procpointer(cp, fp)
  j = 1
  call fp(j)
end subroutine CallIt
```

See the `funcptr` example in SWIG for an example of the callback
functionality in practice.

Currently function pointers only work with
user-created C-linkage functions as described below, but we plan to extend
function callbacks so that data can be translated through wrapper functions.

Another planned extension for function pointers is to automatically generate
the necessary *abstract interface* code required by Fortran to interpret the
function pointer.

## Handles and other oddities

Most combinations of pointers and references (such as `int**`, `int* const*`,
`int*[3]`, `int*&`) are treated as opaque C pointers. They can be passed
through the Fortran/C interface but currently have no special meaning or
operations in generated Fortran code.

```c
double** get_handle();
```
becomes
```fortran
function get_handle() &
    result(swig_result)
  use, intrinsic :: ISO_C_BINDING
  type(C_PTR) :: swig_result
end function
```

Similarly, member function pointers (bound to a member function of a particular
class instance) are supported as opaque Fortran objects.

<!-- ###################################################################### -->

# Basic C/C++ features

This section describes the wrapper and proxy code generated by C and C++
language features.

## Functions

Functions in C/C++ are *procedures* in Fortran. Their arguments correspond
directly between the two languages: one argument in the C code requires one
argument in the Fortran proxy.
(Two exceptions are that C arguments can be ignored by swig using the
`%typemap(in, numinputs=0)` directive in SWIG, and that SWIG supports
multiple-argument typemaps.) A function in C/C++ with a
`void` return value will translate to a `subroutine` in Fortran, and a function
returning anything else will yield a Fortran `function`.

Each function in SWIG has a unique "symbolic name" or *symname* bound to it.
The *symname* must be compatible with C linkage, and thus namespaces, templates,
and overloads are incorporated into the symname, but a symname is often just
the same as the bare function name.
<!--
For example, a function 
```c++
namespace foo {
template<typename T>
void bar(T arg);
}
```
and instantiated with
```swig
%template(bar_dbl) foo::bar<double>;
```
might a symbolic name `bar_dbl
-->

SWIG will generate a wrapper function in the C++ file named `swigc_$symname`,
where `$symname` is replaced with the symname. A corresponding private `BIND(C)`
interface statement will be generated in the Fortran interface module. This
wrapper function is responsible for converting the function's arguments
and return value to and from Fortran-compatible datatypes and calling the C++
function.

In the Fortran module, SWIG generates a public procedure `$symname`
that translates native Fortran data types to and from the C interface
datatypes. This interface, and not the `swigc_$symname` bound function, is the
one used by Fortran application codes.

## Function overloading

There is an important exception to the naming scheme described above:
function overloading, when two or more free functions share a name but have
different arguments. 
For each overloaded function signature, SWIG generates a private procedure with
a unique symname. These procedures are then combined under a
*separate module procedure* that is given a public interface with the original
symbolic name. For example, an overloaded free function `myfunc` in C++ will
generate two private procedures and add an interface to the module
specification:
```fortran
 public :: myfunc
 interface myfunc
  module procedure myfunc__SWIG_0, myfunc__SWIG_1
 end interface
```

It should be noted that a function that returns `void` cannot be overloaded
with a function that returns anything else: generic interfaces must be either
all subroutines or all functions. Use SWIG's `%ignore` statement to hide one or
the other:
```swig
void cannot_overload(int x);
int  cannot_overload(int x, int y);
%ignore cannot_overload(int x);
```

## Global variables

Global variables in SWIG are wrapped with "getter" and "setter" functions. In
the case of a global C++ variable
```c++
namespace foo {
extern int global_counter;
}
```
SWIG will generate functions with interfaces
```fortran
subroutine set_global_counter(value0)
  use, intrinsic :: ISO_C_BINDING
  integer(C_INT), intent(in) :: value0
end subroutine
```
and 
```fortran
function get_global_counter() &
  result(swigf_result)
  use, intrinsic :: ISO_C_BINDING
  integer(C_INT) :: swigf_result
end function
```
Although no type conversion is needed for simple integers, other global data
types would require special wrapper code in these functions.

Currently, global C/Fortran-compatible variables are treated the same as C++
data, but in the future we plan to expand the `%bindc` feature to directly wrap
```c++
extern "C" {
extern int global_counter_c;
}
```
as a C-bound common block variable bound
```fortran
integer(C_INT), bind(C, name="global_counter_c") :: global_counter_c
```

### Global constants

Global constant variables (whether declared in C++ headers with `const` or in
a SWIG wrapper with `%constant`) of native types can be wrapped as Fortran
parameters:
```swig
%parameter approx_pi;
const double approx_pi = 3.1416;
```
will be translated to
```fortran
 real(C_DOUBLE), parameter, public :: approx_pi = 3.1416_C_DOUBLE
```
If the variable is defined in the header file and is a simple integer, this
feature will be enabled by default. It can be explicitly enabled or disabled
using the `%parameter` and `%noparameter` directives.

Global constants that have the feature disabled will be wrapped as a
`protected, public, bind(C)` value with the value defined in the C wrapper code.

## Classes

As mentioned previously, C++ classes are transformed to Fortran *derived
types*. These types have *type-bound procedures* that mirror the C++ *member
functions*.  Other SWIG target languages refer to the transformed wrapper
classes as "proxy classes" because they act as a proxy to the underlying C++
class.

The Fortran "proxy class" is effectively a C pointer with memory management
metadata and type-bound accessors. The C pointer is initialized to
`C_NULL_PTR`, and when assigned it
can represent a class as a _value_ (i.e. the local Fortran code has ownership)
or by _reference_. The classes and their implementation are described in detail
in the [proxy classes](#proxy-classes) section.

## Exceptions

By default, a C++ exception will call `std::terminate`, abruptly
aborting the Fortran program execution. With the `%exception` feature, C++
exceptions can be caught and handled by the Fortran code by setting and
clearing an integer flag. The following snippet
from the Examples directory illustrates its use in printing and ignoring an
error:
```fortran
use except, only : do_it, ierr, get_serr
call do_it(-3)
if (ierr /= 0) then
  write(0,*) "Got error ", ierr, ": ", get_serr()
  ierr = 0
endif
```

Enabling this exception handling requires `%include`ing a special file and
writing a small exception handler.
```swig
%include <std_except.i>

%exception {
  // Make sure no unhandled exceptions exist before performing a new action
  SWIG_check_unhandled_exception();
  try {
    // Attempt the wrapped function call
    $action
  } catch (std::exception& e) {
    SWIG_exception(SWIG_RuntimeError, e.what() );
  } catch (...) {
    SWIG_exception(SWIG_UnknownError, "An unknown exception occurred");
  }
}

%inline %{
#include <stdexcept>
void do_it(int i)
{
  if (i < 0) throw std::runtime_error("Bad value");
}
%}
```

The above code will wrap (by default) *every* function call. (The standard SWIG
`%allowexception` and `%noallowexception` directives can be used to selectively
enable or disable exception handling.) Before calling the wrapped function,
the call to `SWIG_check_unhandled_exception` ensures that no previous unhandled
error exists.  If you wish to wrap only a few functions with only specific
exceptions, use the ["throws" typemap](SWIG.html#throws_typemap).

When exception handling code is used, SWIG generates a few internal data
structures as well as two externally accessible symbols with external C linkage
(`ierr` and `get_serr`). Fortran bindings are generated to make the integer and
function accessible from the Fortran module.

The names of the integer and string accessor have C linkage and thus must
be unique in a compiled program. Since other translation units might have
symbols that share the default exception handling names, the user can provide
custom names before including the exception handling file:
```swig
#define SWIG_FORTRAN_ERROR_INT my_ierr
#define SWIG_FORTRAN_ERROR_STR get_my_serr
%include <std_except.i>
```

If you're linking multiple modules together (using %import or otherwise), only
one of those modules should define the error integer and accessor. Every other
module needs to add
```swig
%include <extern_exception.i>
```
before any other module is `%import`ed (or any other exception-related source
files are `%include`d). This inserts the correct exception macros in the
wrapper code and *declares* (but does not define) the external-linkage error
function and variable. You must also ensure the `SWIG_FORTRAN_ERROR_INT` macro
is correctly defined before this include if it's being used upstream.

If you forget to make the above inclusion and an `%import`ed module loads
`exception.i`, a SWIG error will be displayed with a reminder of what to do. If
*all* of your modules declare `extern_exception.i`, 

<!-- ###################################################################### -->

# Provided typemaps

There are many ways to make C++ data types interact more cleanly with Fortran
types. For example, it's common for C++ interfaces take a `std::string` when
they're typically called with string literals: the class can be implicitly
constructed from a `const char*` but can also accept a `std::string` if needed.
Since Fortran has no implicit constructors, passing a string argument would
typically require declaring and instantiating a class for that variable.
To mitigate this annoyance, special typemaps are provided that
transparently convert between Fortran types and C++ types.

Generally, these typemaps are defined as applying to arguments called `NATIVE`;
they can be applied to *all* arguments regardless of name with the `%apply`
directive:
```swig
%apply const char* NATIVE { const char* };
```
or to the output of a specific function such as `const char* get_foo_string(int
i);`
with
```swig
%apply const char* NATIVE { get_foo_string };
```

## C string

A long-standing difficulty with Fortran/C interaction has been the two
languages' representation of character strings.
The size of a C string is determined by counting the number of characters until
a null terminator `\0` is encountered. Shortening a string requires simply
placing the null terminator earlier in the storage space.
In contrast,
the historical Fortran string is a character array sized at compile
time: representing a smaller string at run time is done by filling the
storage with trailing blanks.
The Fortran intrinsic `LEN_TRIM` returns the length of a string without
trailing blanks, and the `TRIM` function is used if necessary to return a
string with those trailing blanks removed. Of course, this definition of a
string means `foo` and `foo ` are equivalent.

Starting with Fortran 90, strings with an unambiguous size can be dynamically
allocated:
```fortran
character(kind=C_CHAR, len=:), allocatable :: mystring
allocate(character(kind=C_CHAR, len=123) :: mystring)
```
and the length is given by `LEN(mystring)`.

Including the `<cstring.i>` library file defines input and output typemaps for
`const char* NATIVE`. These typemaps assume that both the input and output are
standard null-terminated C strings on the C++ side, and a variable-length
string on the Fortran side (i.e. any trailing blanks are intentional). Note
that by using null-terminated strings, if a Fortran string has null characters
embedded in it, the string will be truncated when read by C. Thus the function
as written is *not* suitable for passing binary data between C and Fortran.

If a function `char* to_string(float f);` emits a `malloc`'d string value,
and the output is to be wrapped by SWIG, use the `%newobject` feature to
avoid memory leaks:
```swig
%apply const char* NATIVE { char* to_string };
%newobject to_string;
char* to_string(float f);
```

The Fortran-to-C string translation performs the following steps:
1. Allocates a character array of `len(string) + 1`
2. Copies the string contents into that array and sets the final character to
   `C_NULL_CHAR`
3. Saves the C pointer to the character array using `C_LOC` and the size to a
   small `SwigArrayWrapper` struct
4. Passes this struct to the C wrapper code, which uses the data pointer.

The C-to-Fortran string translation is similar:
1. Use `strlen` to save the string length to `SwigArrayWrapper.size`, and save
   the pointer to the data; return this struct to Fortran
2. Call `C_F_POINTER` to reinterpret the opaque C pointer as a character array
3. Allocate a new string with a length determined by the `size` member
4. Copy the character array to the new string
5. If the `%newobject` feature applies, call the C-bound `free` function.

The intermediate step of allocating and copying an array is required not only
to add a null terminator but also because the Fortran standard prohibits taking
the C address of a dynamic-length string.

Improved support for the various character typemaps and representations (as in
the standard SWIG `<cstring.i>` which provides `%cstring_bounded_output`) could
be implemented in a later version of SWIG.

Note: it seems that some Fortran compilers (gfortran 5.5) emit a spurious
warning when assigning an allocatable string returned by one of these
functions:
```
Warning: '.str' may be used uninitialized in this function [-Wmaybe-uninitialized]
```

## Std::string

A special set of typemaps is provided that transparently converts native Fortran
character strings to and from `std::string` classes. It operates essentially
like the `<cstring.i>` function described above but makes no requirements or
assumptions about null terminator characters.

This typemap is provided in `<std_string.i>`, which also defines the
`std::string` class for wrapping. If you want only the typemaps but not a proxy
class definition for `string`, then simply `%ignore` it before loading the
file:
```swig
%ignore std::string;
%include <std_string.i>
```

An example of using this typemap is for a dictionary where the "key" is
typically a string that needs no manipulation:
```swig
%include <std_string.i>
%apply const std::string& NATIVE { const std::string& key };

class Dict {
public:
  template<class T>
  const T& get(const std::string& key, const T& default);
};

%template(get) Dict::get<int>;
%template(get) Dict::get<double>;
%template(get) Dict::get<std::string>;
```

Note that since only parameters named `key` use this typemap, the `std::string`
instantiation of the function still requires and returns a class instance.
```fortran
type(Dict), intent(in) :: mydict
type(string) :: default_str
type(string) :: result_str
type(C_INT) :: result_int
type(C_DOUBLE) :: result_dbl

result_int = mydict%get("an integer", 123)
result_dbl = mydict%get("a double", 123.d0)

default_str = create_string("default")
result_str = mydict%get("a string", default_str)
```

As demonstrated above with C strings, and like other typemaps, the `NATIVE`
typemap can be applied to the output of only a particular function `const
std::string& get_foo()` using
```swig
%apply const std::string& NATIVE { const std::string& get_foo };
```

The Fortran/C string translation works as described in the [C
strings](#c-strings) section, except the exact string size is retained when
moving from Fortran to C, and `s.size()` is used rather than
`strlen(s)` when copying a string from C to Fortran.

## Smart pointers

Like other target languages, SWIG can generate Fortran wrappers to *smart
pointers* to C++ objects by modifying the typemaps to that object.
A smart pointer is an object whose interface mimics a raw C
pointer but encapsulates a more advanced implementation that manages the memory
associated with that pointer.  Different libraries provide different names and
interfaces to smart pointers, but the common `std::shared_ptr` class (and the
less common `boost::shared_ptr`) interfaces are provided and can be easily
adapted to other similar "smart pointer" types.

When a shared pointer is
copied, the pointed-to object is "shared" by the two shared pointer instances,
and a reference counter (which keeps track of the number of existing shared
pointer instances) is incremented. A shared pointer's reference count is
decremented when its destructor is invoked, or if `reset()` is
called on the pointer. When the reference count reaches zero, the pointed-to
object is deleted.

Wrapping shared pointers with SWIG is as simple as adding the line
`%shared_ptr(Foo)` to the source file before the definition of class `Foo` or
the wrapping of any function that uses an instance of `Foo`. That macro defines
all the necessary typemaps to convert a shared pointer to and from a value,
raw pointer, or reference.  SWIG does *not* require that all uses of `Foo` be as
`shared_ptr<Foo>`: for example, it will correctly dereference the shared
pointer when passing it into a function that takes a const reference.
Additionally, because shared pointer class supports "null deleters" (i.e. when
the reference count reaches zero, the pointed-to data will *not* be deleted),
the code can embed a non-owning reference to the data in a shared pointer. In
other words, it is OK to return `const Foo&` even when `Foo` is wrapped as a
shared pointer.

The following example illustrates the memory management properties of smart
pointers. The SWIG interface file is
```swig
%module spdemo;
%include <std_shared_ptr.i>
%shared_ptr(Foo);

%inline %{
#include <memory>
class Foo {
public:
  explicit Foo(int val) {}
  ~Foo() {}
  const Foo *my_raw_ptr() const { return this; }
};

int use_count(const std::shared_ptr<Foo> *f) {
  if (!f) return 0;
  return f->use_count();
}
%}
```
and the user code is:
```fortran
#define ASSERT(COND) if (.not. (COND)) stop(1)
program main
  use ISO_FORTRAN_ENV
  use spdemo, only : Foo, create_foo, use_count
  type(Foo) :: f1, f2

  ASSERT(use_count(f1) == 0)
  f1 = create_foo(1) ! Construct
  ASSERT(use_count(f1) == 1)
  f2 = f1 ! Copy shared pointer, not underlying object
  ASSERT(use_count(f1) == 2)
  ASSERT(use_count(f2) == 2)

  f2 = create_foo(2) ! Create a new object, assigning the *shared pointer*
                     ! but not replacing the underlying object.
  ASSERT(use_count(f1) == 1)
  ASSERT(use_count(f2) == 1)

  f1 = f2%my_raw_ptr() ! Return a non-shared pointer
                       ! and call the destructor of C++ object 1
  ASSERT(use_count(f2) == 1)

  call f1%release() ! Clear the raw pointer (does not deallocate)
  ASSERT(use_count(f1) == 0)
  call f2%release() ! Destroy the last existing shared pointer
                    ! which then destroys the C++ object 2
  ASSERT(use_count(f2) == 0)

  call f2%release() ! Further calls to release() are allowable null-ops
end program
```

## Array views

The `<view.i>` library file provides a simple means of converting to and from
Fortran array pointers. It translates `std::pair<T*, size_t>` input and
output values to and from Fortran array pointers. See the section on [pointers
and references](#pointers-and-references) for cautions on functions returning
pointers, but in short, the wrapper code
```swig
#include <view.i>
ADD_VIEW(double)
std::pair<double*, size_t> get_array_ptr();
```
is usable in Fortran as
```fortran
real(C_DOUBLE), pointer :: arrptr(:)
arrptr => get_array_ptr()
```

Since this library file is so simple, it can be used as a template for creating
transparent wrappers between Fortran arrays and other C++ data types.  For
example, the following snippet based on `<view.i>` converts
a return value of `std::vector<double>& NATIVE` to a Fortran array pointer and
applies it to a function `as_array_ptr`.
```swig
%include <forarray.swg>

// Convert a reference-to-vector return value into a array view.
FORT_ARRAYPTR_TYPEMAP(double, std::vector<double>& NATIVE)
%typemap(out) std::vector<double>& NATIVE %{
  $result.data = $1->empty() ? NULL : $1->data();
  $result.size = $1->size();
%}

%apply std::vector<double>& NATIVE { std::vector<double>& as_array_ptr };
```

## MPI compatibility

When wrapping a C++ library that includes MPI support, and the Fortran
application uses MPI through the `mpif.h` interface (or `mpi` module), it is
often necessary to pass MPI communicators between Fortran and C++. The
`<mpi.h>` library header provides bindings to convert between `mpif.h`-defined
`integer` communicator values and the standard C `MPI_Comm` datatype. It works
by calling the MPI standard functions `MPI_Comm_f2c` and `MPI_Comm_c2f`.

Note that this library inserts include guards into the wrapper code, for the
case when it's distributed on a system that doesn't support MPI. It is
necessary to inject a configuration file that defines `#define HAVE_MPI` when
MPI is available.

This example sets a communicator in C++:
```swig
%insert("runtime") %{
#include "myconfig.h"
%}
%include <mpi.h>
void set_my_comm(MPI_Comm comm);
```
using the Fortran MPI-native communicator:
```fortran
use mpi
call set_my_comm(MPI_COMM_WORLD)
```

## Integer types

One other note to be made about Fortran interoperability concerns the mismatch
between default Fortran integers and C++'s `size_type`, which is often used as
a parameter. The differing `KIND` of the integers requires that users awkwardly
cast values when passing into function calls:
```fortran
call my_vector%resize(INT(n,C_LONG))
```
This nuisance can be simply avoided by replacing occurrences of C's size type
with the native Fortran integer type:
```swig
%apply int { std::size_t }
```
Note of course that if the native integer type is 32-bit and the long type is
64-bit, this will prevent any input larger than `0x7fffffff` from being passed
as a parameter.

<!-- ###################################################################### -->

# Proxy classes

Each C++ class (with the exception of those wrapped using [direct C
binding](#direct-c-binding)) creates a "proxy"
class in the Fortran module: it is a thin wrapper that binds a C++ pointer to
the corresponding SWIG-wrapped C++ methods. These classes are *strongly typed*:
the compiler enforces type checking instead of runtime type checking being
performed (which is the case with many other SWIG-wrapped languages).

Memory management in Fortran is vastly different from C and C++: it is designed
for much simpler computers of the past where every subroutine and variable in
the computer memory had a specific address. Effectively, all data in Fortran
(with the exception of functions declared `RECURSIVE`) is static: it will be
initialized once and will persist between leaving and reentering a subroutine.

This presents significant difficulties when working with C++ classes, which
often are predicated on having limited scope so that their destructor is called
to release resources. We have implemented a partial workaround that tracks
memory ownership inside Fortran and C++; as a bonus it enables const
correctness.

Every proxy class holds a single piece of data, a small C-bound struct named
`SwigClassWrapper`, which contains two simple members: a pointer to C-owned
memory, and an enumeration that tracks the ownership of that memory.

## Constructors and Destructors

In C++, the allocation and initialization of a class instance is (almost
without exception) performed effectively simultaneously using a constructor.
The initialization can be arbitrarily complex, and since the constructor can be
overloaded, the instance can be allocated and initialized by several different
code paths. In Fortran, initialization can only assign simple scalars and set
pointers to null. 

Because of limitations in [function overloading](#function-overloading) with
[inheritance](#inheritance) in Fortran, it is not generally possible to provide
type-bound procedures that mirror the C++ constructors.
The design decision was
made to construct objects by calling procedures *not* bound to a type. The
constructor is wrapped as `create_{symname}`:
```fortran
type(Foo) :: f
type(Foo) :: g
f = create_Foo()
g = create_Foo(123)
call f%do_something()
call g%do_something_else()
```

Even though the Fortran 2003 standard specifies when local variables become
*undefined* (and are *finalized* if they have a `FINAL` subroutine), support
for finalization in even the latest compilers is not entirely reliable. Rather
than relying on the finalization mechanics to clean up and free a C++ object,
destructors for the C++ wrappers wrapped as a `release` procedure:
```fortran
call f%release()
call g%release()
```
To avoid leaking memory, `release` should *always* be called when the proxy
class instance is no longer needed. It will free memory if appropriate and
reset the C pointer to `NULL`. Calling `release` on an uninitialized variable
(or a variable that has been released) is a null-op.

Because Fortran 2003 does specify support for a special `FINAL` procedure to
clean up local or dynamic variables, the call to `release()` can be replaced by
adding a `FINAL` procedure. The SWIG Fortran interface can generate this
procedure, which will call the C++ destructor:
```swig
%feature("final") Foo;
%include "Foo.h"
```
**However**, this feature is relatively untested and its behavior could be
compiler-dependent, so extreme caution is recommended when enabling it.

## Member functions

SWIG generates unique, private procedure names for each class and function.
These procedures are bound to the type. If [function
overloading](#function-overloading) is used, "generic" procedures will be added
to the derived type.

Type-bound procedures in Fortran proxy classes are treated exactly the same as
for native derived types:
```fortran
integer(C_INT) :: value
type(Foo) :: food
food = create_Foo()
call food%do_something()
value = food%get_something()
```
Function overloading for derived types is implemented using *generic
interfaces*. Each overloaded function gets a unique internal symname, and they
are bound together in a generic interface. For example, if a member function
`doit` of class `Action` is overloaded, a generic binding will be generated
inside the Fortran proxy derived type:
```fortran
  procedure, private :: doit__SWIG_0 => swigf_Action_doit__SWIG_0
  procedure, private :: doit__SWIG_1 => swigf_Action_doit__SWIG_1
  generic :: doit => doit__SWIG_0, doit__SWIG_1
```

As with [free functions](#function-overloading), a member function returning
`void` cannot be overloaded with a function returning non-void.

## Member data

SWIG generates member functions for class member data in the same way that it
generates free functions for [global variables](#global-variables). Each public
member produces a "getter", and unless the data is marked `const`, it
generates a "setter". 

For a struct
```c++
struct Foo {
  int val;
};
```
the interface to an instance and its data is:
```fortran
type(Foo) :: f
f = create_Foo()
call food%set_val(123)
value = food%get_val()
```

## Inheritance

Single inheritance in C++ is mirrored by Fortran using the `EXTENDS` attribute.
For classes with virtual methods, the user should keep in mind that function
calls are dispatched through C++. In other words, even if you call a base-class
member function in Fortran that wraps a derived class instance, the correct
virtual function call will be dispatched.

Fortran has no mechanism for multiple inheritance, so this SWIG target language
does not support it. The first base class listed that has not been `%ignore`d
will be treated as the single parent class.

There is no intrinsic way to `dynamic_cast` to a daughter class, but
if a particular casting operation is needed a small inline function can be
created that should suffice:
```swig
%inline %{
Derived& base_to_derived(Base& b) {
    return dynamic_cast<Derived&>(b);
}
%}
```
(Note that this function will *not* transfer ownership to the new object. Doing
that is outside the scope of this chapter.)

The implementation of [function overloading](#function-overloading) in the
Fortran types can cause compiler errors when member functions are *shadowed* or
*overridden* in a daughter class. First, Fortran requires essentially that
overriding procedures must have the exact same function signature *including
the names of the dummy arguments*. Overriding functions in C++ merely require
the same parameter types. Second, Fortran does not allow a procedure in a
parent type to be "shadowed" by the extending type as C++ does. Finally,
a non-generic procedure in the parent type cannot be shadowed by a generic
procedure.

## Memory management

A single Fortran proxy class must be able to act as a value, a pointer, or a reference to a C++ class instance.
When stored as a value, a method must be put in place to deallocate the
associated memory; if the instance is a reference, that same method cannot
double-delete the associated memory. Finally, C++ functions
must be able to send Fortran pointers both *with and without* owning the
associated memory, depending on the function. Finally,
assignment between Fortran classes must preserve memory association.

Fortran's "dummy argument" for the return result of any function (including
generic assignment) is `intent(out)`, preventing the previous contents (if any)
of the assignee from being modified or deallocated.
At the same time, the assignment operator must behave correctly in both of
these assignments, which are treated identically by the language:
```fortran
 type(Foo) :: a, b
 a = make_foo()
 b = a
```
Note that unlike Python, `b` is not a pointer to `a`; and unlike C++, `b` is
not copy-constructed from `a`. Instead, `a` is assigned to `b` using the
`assignment(=)` operator. Likewise, `a` is not "constructed" on the second
line: there is no return value optimization as in C++. Instead, `make_foo`
returns a temporary `Foo`, and that *temporary* is assigned to `a`.

Because these two assignments are treated equally and a temporary is created in
only one of them, we have to be clever to avoid leaking or double-deleting
memory.

Ideally, as was done in Rousson's implementation of Fortran shared pointers, we
could rely on the `FINAL` operator defined by Fortran 2003 to release the
temporary's memory. Unfortunately, even 15 years after the standard was
ratified, support for `FINAL` is patchy and unreliable.

Our solution to this limitation is to have the `Foo` proxy class store not only
a pointer to the C data but also a state enumeration `self%swigdata%mem` that
describes memory ownership. The enumeration needs to have at least three options:
- The memory is *owned* by the proxy class (and must be deleted when calling
  `release()`);
- The proxy class is a *reference* to memory owned by C/C++ (returned by either
  a raw pointer or a reference);
- The memory is being allocated and returned from a function, but it must be
  captured by the left hand side.

This last option is roughly analogous to the behavior of the deprecated
`std::auto_ptr`, which was the predecessor to C++11's `move` semantics.
Besides the above flags, we also define an "uninitialized" state for
convenience, and a "const reference" state to enable const correctness. These
flags are set by the SWIG `out` typemaps in the C wrapper code: if memory is
being allocated, the return flag is `MOVE`; if a pointer is being returned,
`REF` (or `CREF` in the const case) is used.

The final trick is to implement an assignment operator that correctly copies,
allocates, or moves memory based on the flags on the left- and right-hand sides,
and sets a new memory state on the recipient. By resetting the state flag in a
generic assignment operator, we guarantee that *only* temporary classes will
ever have the `MOVE` state.

For the operation `self = other`, where `other` may be a return value from a
function or another class, the following actions are taken. (In the example,
both classes are of type `This`, and `pself` and `pother` are the pointers
being managed.)

| Self   | Other        | *Action*                                |
| ---    | -----        | --------                                |
| NULL   | NULL         | (none)                                  |
| NULL   | MOVE         | `pself = pother;`                       |
| NULL   | OWN          | `pself = new This(pother);`             |
| NULL   | REF/CREF     | `pself = pother;`                       |
| OWN    | NULL         | `delete pself; pself = NULL;`           |
| OWN    | MOVE         | `*pself = move(*pother); delete pother;`|
| OWN    | OWN          | `*pself = *pother;`                     |
| OWN    | REF/CREF     | `*pself = *pother;`                     |
| REF    | NULL         | `pself = NULL`                          |
| REF    | MOVE         | `*pself = move(*pother); delete pother;`|
| REF    | OWN          | `*pself = *pother; `                    |
| REF    | REF/CREF     | `*pself = *pother;`                     |
| CREF   | NULL         | `pself = NULL`                          |
| CREF   | MOVE         | (error)                                 |
| CREF   | OWN          | (error)                                 |
| CREF   | REF/CREF     | (error)                                 |
                                                                
The above operations are designed to preserve C++ semantics: if an proxy object
owning memory is assigned, then any existing objects pointing to that memory
will reflect the newly assigned value.

The fact that some classes disallow combinations of copy/move
constructors and assignment complicates the task of evaluating the above
actions. SWIG's built-in parsing of class features is usually sufficient to
determine when a class can be copy-assigned or copy-constructed. If C++11 is
enabled, standard library type traits override the SWIG-parsed features and
additionally enable move construction and move assignment.

Memory can still be leaked, of course, by calling `make_foo()` without
capturing and releasing the result, or by failing to call `release` on a proxy
class.

## Opaque class types

SWIG's default Fortran type (the `ftype` typemap) for generic types such as
classes (`SWIGTYPE`) is:
```swig
%typemap(ftype) SWIGTYPE "type($fclassname)"
```
The special symbol `$fclassname` is replaced by the symbolic name of the class
that matches the typemap. For example, if `std::vector<double>` is
instantiated:
```swig
%template(Vec_Dbl) std::vector<double>;
```
then `Vec_Dbl`, the name of the derived type, will replace `$fclassname`.

If a class has *not* been wrapped but is encountered (e.g. in a function
argument or return value), a warning will be emitted: no Fortran
derived type has been generated to correspond to the C++ class. A new derived
type `SwigUnknownClass` will be generated that simply holds an opaque pointer
to the C++ object. This derived type can still be used with the C interface,
but it will behave as a raw `void*` pointer: no type checking will be performed
on the unknown class. You must be very careful to pass the right class to the
right function call.

## Proxy class wrapper code

The Fortran wrapper code generated for each function can be extended in
multiple ways besides using the `fin` and `fout` typemaps. A specific function
can have code prepended to it using the `%fortranprepend` macro (which is a
compiler macro for `%feature("fortran:prepend")`) and appended using
`%fortranappend` (which aliases `%feature("fortran:append")`.

For advanced cases, the function or subroutine invocation can be embedded in
another layer of wrapping using the `%feature("shadow")` macro. The
special symbol `$action` will be replaced with the usual invocation.

<!-- ###################################################################### -->

# Advanced

## Direct C binding

It is sometimes desirable to simply expose C functions and types to Fortran.
(Of course, this may be done only when the data types involved are ISO-C
compatible.)

### Generating C-bound Fortran types from C structs

In certain circumstances, C++ structs can be wrapped natively as Fortran
`BIND(C)` derived types, so that the underlying data can be shared between C
and Fortran without any wrapping needed. Structs that are "standard layout" in
C++ can use the `%bindc` feature to translate
```c++
struct BasicStruct {
  int foo;
  double bar;
};
```
to
```fortran
type, bind(C) :: BasicStruct
  integer(C_INT), public :: foo
  real(C_DOUBLE), public :: bar
end type
```
Roughly speaking, standard layout structs have no virtual member functions,
inheritance, or C++-like member data. All structs in C are compatible with
Fortran, unless they bit have fields or use the C99 feature of "flexible array
members".

Currently the C binding feature for structs must be activated using a special
macro `%fortran_bindc_struct`:
```swig
%fortran_bindc_struct(BasicStruct);
```

 In C++, these structs
must be "standard layout", i.e. compatible with C. ()

Calling `%fortran_bindc_struct(Foo)` inhibits default constructor/destructor
generation for the class, and it sets up the necessary type definitions to
treat the struct as a fundamental type.

Every member of the struct must be `BIND(C)` compatible. This is enforced with
a separate typemap `bindc` that translates the member data to Fortran type
members. For example, the basic `int` mappings are defined (using macros) as:

```swig
%typemap(bindc) int      "integer(C_INT)"
%typemap(bindc) int*     "type(C_PTR)"
%typemap(bindc) int[ANY] "integer(C_INT), dimension($1_dim0)"
%typemap(bindc) int[] = int*;
```

The `bindc` typemap is used when wrapping global constants as well.

### Interfaces with Fortran C-bound types

If types defined in the SWIG Fortran module are to be used as part of the
interface (as is the case with structs), it is necessary to "import" the type
into the interface to use it. This is accomplished by the `import` keyword
argument to the `imtype` typemap. For
example, whenever the following typemap is used in the intermediate wrapper:
```swig
%typemap(imtype, import="SwigArrayWrapper")  FooArray
  "type(SwigArrayWrapper)";
```
an `import` directive will be inserted into the Fortran proxy
function:
```fortran
module thinvec
 use, intrinsic :: ISO_C_BINDING
 implicit none

 type, public, bind(C) :: SwigArrayWrapper
   type(C_PTR), public :: data
   integer(C_SIZE_T), public :: size
 end type
 interface
 subroutine swigc_foo(farg1) &
   bind(C, name="swigc_foo")
   use, intrinsic :: ISO_C_BINDING
   import :: SwigArrayWrapper    ! Will not compile without this line
   type(SwigArrayWrapper) :: farg1
 end subroutine
```

This extra typemap trickery should only be needed if you're generating bound
types without using the `%fortran_bindc_struct` macro.

### Generating direct Fortran interfaces to C functions

In addition to generating functions with translation code, it is
also possible to specify that a function be directly *bound* and not *wrapped*.
For this feature to work correctly, all function arguments and return types
must be inherently Fortran/C interoperable. If using C++, the function must be
defined using `extern "C"` linkage; and in fact, when SWIG is asked to wrap a
function with that linkage, it defaults to binding it. Use the `%nobindc
my_func_name;` feature to suppress this behavior.

The C++ code:
```c++
extern "C" {
// These functions are simply bound, not wrapped.
void print_sphere(const double origin[3], const double* radius);
}
```
is automatically translated into
```fortran
subroutine print_sphere(origin, radius) &
    bind(C, name="print_sphere")
  use, intrinsic :: ISO_C_BINDING
  real(C_DOUBLE), dimension(3), intent(in) :: origin
  real(C_DOUBLE), intent(in) :: radius
end subroutine
```

<!-- ###################################################################### -->

## Typemaps

SWIG Fortran extends the typemap system of SWIG with additional typemaps,
modeled after the Java target language's typemaps. They provide for translating
C++ data to and from an ISO-C compatible datatype, and from that
datatype to native Fortran types.

### ISO C Wrapper interface

There
are two new typemaps to declare the data types used by Fortran and C in the
intermediate layer, and two typemaps for translating the intermediate layer
types to the final Fortran types.

To pass Fortran-2003 compatible `BIND("C")` or `ISO_C_BINDING` types between
C++ and Fortran, you
must declare a compatible `ctype` and `ftype`. The `ctype` is the C datatype
used by the wrapper and intermediate layer, and `ftype` is the equivalent
Fortran datatype. These datatypes generally must be either fundamental types or
structs of fundamental types. For example, as described in `Fundamental types`
section, the `int` C type corresponds to the `integer(C_INT)` Fortran type.

Note that fundamental types include the opaque
pointer `void*` and its Fortran equivalent `type(C_PTR)` as well as function
pointers and the opaque Fortran equivalent `type(C_FUNPTR)`.

### Fortran proxy datatype translation

The `fin` and `fout` typemaps are Fortran proxy wrapper code analogous to the
`in` and `out` in the C wrapper code: they are used for translating native
Fortran objects and types into types that can be transmitted through the C
layer. For example, to pass a class by reference, the Fortran class
`class(SimpleClass) :: self` is converted to the corresponding C class via the
stored C pointer using the `fin` typemap, which is expanded to:
```fortran
farg1 = self%swigdata%ptr
```
This argument is then passed into the C function call:
```fortran
fresult = swigc_make_class(farg1)
```
and the output is translated back via the `fout` typemap, which in this case expands to:
```fortran
swig_result%swigdata%ptr = fresult
```

### Special overrides for return variables

Sometimes a return type in C++ needs additional contextual information to be
meaningful in Fortran. For example, a returned pointer may be the first element
in a C array but requires a size to be used as an array. Since special typemaps
cannot be applied to output variables like they can for inputs (i.e.
`%typemap(in) int* OUTPUT`), we provide a `%feature` directive for additional
customization.

Consider a vector-like C++ class:
```c++
class Array {
public:
  double* data();
  int size();
};
```

With typemaps alone, it's impossible to convert the return value from `data` to
a sized array pointer in Fortran. (By default, `data` is interpreted as a
scalar pointer.) Since the SWIG `%feature` directive can be applied to specific
functions and methods, we can use `%feature("ftype")` and `%feature("fout")` to
override the `%typemap("ftype") double*` and `%typemap("fout") double*`:
```swig
%feature("ftype") Array::data %{
real(C_DOUBLE), dimension(:), pointer
%}
%feature("fout") Array::data %{
call c_f_pointer($1, $result, [self%size()])
%}
```

### Allocating local Fortran variables in wrapper codes

Advanced SWIG users may know that 
```swig
%typemap(in) int (double tempval) { /.../ }
```
is a way to declare a temporary variable `tempval` in the C wrapper code. The
same feature is emulated in the special typemaps `findecl` and `foutdecl`,
which are inserted into the variable declaration blocks when the corresponding
types are used. If `findecl` allocates a temporary variable, the `ffrearg`
typemap (analogous to the `freearg` typemap for C `in` arguments) can be used
to deallocate it.

An example for returning a native `allocatable` Fortran string from a C++
string reference must declare a temporary array pointer to the C data, then
copy the result into a Fortran string.
```swig
%typemap(ftype, out="character(kind=C_CHAR, len=:), allocatable")
    const std::string&
"character(kind=C_CHAR, len=*), target"

// Fortran proxy translation code: temporary variables for output
%typemap(foutdecl) const std::string&
%{
 integer(kind=C_SIZE_T) :: $1_i
 character(kind=C_CHAR), dimension(:), pointer :: $1_chars
%}

// Fortran proxy translation code: convert from imtype $1 to ftype $result
%typemap(fout) const std::string&
%{
  call c_f_pointer($1%data, $1_chars, [$1%size])
  allocate(character(kind=C_CHAR, len=$1%size) :: $result)
  do $1_i=1,$1%size
    $result($1_i:$1_i) = $1_chars($1_i)
  enddo
%}
```

### Special class typemaps

To facility the wrapping and customizability of C++ classes, there are a few
additional special typemaps that only apply to classes. They generally should
not need to be modified.

The `fdata` typemap declares the data object that is stored by the Fortran
proxy class. Note that only the base class of any inheritance hierarchy
contains this data.

The `fdestructor` typemap becomes the Fortran wrapper code for the `release`
type-bound procedure. The special token `$action` is replaced by the call to
the C wrapper for the destructor. Currently, all classes have the same
destructor action but this may change. (TODO: should this be a `%feature`? Or
should `%feature("unref")` be a typemap?)

## Fragments

The `%insert(section) %{ ...code... %}` directive can be used to inject code
directly into the C/C++ wrapper file as well as the Fortran module file. The
Fortran module uses several additional sections that can be used to insert
arbitrary extensions to the module. For example, if an `%insert` directive is
embedded within a class `%extend`, new type-bound procedures can be manually
added to the derived type.

<table>
<thead>
<tr><th>Name</th><th>Description</th></tr>
<tr><th colspan=2>C++ WRAPPER CODE</th></tr>
</thead>
<tbody>
<tr><td><code>begin   </code></td><td>Immediately below SWIG header comment </td></tr>
<tr><td><code>runtime </code></td><td>Run time code (beginning of .cxx file)</td></tr>
<tr><td><code>header  </code></td><td>Header code (after runtime)           </td></tr>
<tr><td><code>wrapper </code></td><td>C++ wrapper code (middle of .cxx file)</td></tr>
<tr><td><code>init    </code></td><td>Initialization code (end of .cxx file)</td></tr>
</tbody>
<thead>
<tr><th colspan=2>FORTRAN WRAPPER CODE</th></tr>
</thead>
<tbody>
<tr><td><code>fbegin     </code></td><td>Code before the `module` statement </td></tr>
<tr><td><code>fmodule    </code></td><td>Start of module:                   </td></tr>
<tr><td><code>fpublic    </code></td><td>Public interface functions         </td></tr>
<tr><td><code>fparams    </code></td><td>Enums and parameters               </td></tr>
<tr><td><code>ftypes     </code></td><td>Fortran classes                    </td></tr>
<tr><td><code>finterfaces</code></td><td>Fortran class constructors         </td></tr>
<tr><td><code>fwrapper   </code></td><td>Fortran subroutines (proxy code)   </td></tr>
</tbody>
</table>

The generated C++ wrapper file looks like:
```c++
{begin}
{runtime}
{header}
#ifdef __cplusplus
extern "C" {
#endif
{wrapper}
#ifdef __cplusplus
}
#endif
{init}
```

The generated Fortran module looks like:

```fortran
{fbegin}
module [MODULE_NAME]
 use, intrinsic :: ISO_C_BINDING
 {fmodule}
 implicit none
 private
 {fpublic}
 ! module generic interfaces
 {fparams}
 {ftypes}
interface
 {finterfaces}
end interface
contains
 {fwrapper}
end module
```

## Known Issues

A number of known limitations to the SWIG Fortran module are tracked at
https://github.com/sethrj/swig/issues/59 .
